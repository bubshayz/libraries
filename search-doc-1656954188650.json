[{"title":"network","type":0,"sectionRef":"#","url":"api/network","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"network","url":"api/network#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"network","url":"api/network#Server","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; network.Server: NetworkServer A reference to the NetworkServer module.  "},{"title":"client​","type":1,"pageTitle":"network","url":"api/network#client","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; network.client: networkClient A reference to the networkClient module. "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Disconnect: () → () Connected: boolean }  "},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#properties","content":" "},{"title":"ClientRemoteSignal​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#ClientRemoteSignal","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientRemoteSignal.ClientRemoteSignal: Type An exported Luau type of a client remote signal object. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"is​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#is","content":"&lt;/&gt; ClientRemoteSignal.is(self: any) → boolean Returns a boolean indicating if self is a client remote signal or not.  "},{"title":"connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#connect","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:connect(callback: (...any) → ()) → SignalConnection Connects callback to the client remote signal so that it is called whenever the serverside remote signal (to which the client remote signal is connected to) dispatches some data to the client remote signal. The connected callback is called with the data dispatched to the client remote signal.  "},{"title":"connectOnce​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#connectOnce","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:connectOnce(callback: (...any) → ()) → SignalConnection Works almost exactly the same as ClientRemoteSignal:connect, except the connection returned is disconnected immediately upon callback being called.  "},{"title":"disconnectAll​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#disconnectAll","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:disconnectAll() → () Disconnects all connections connected via ClientRemoteSignal:connect or ClientRemoteSignal:connectOnce.  "},{"title":"fireServer​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#fireServer","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:fireServer(...: any) → () Fires ... arguments to the serverside remote signal (to which the client remote signal is connected to).  "},{"title":"wait​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#wait","content":"ClientRemoteSignal instance yields &lt;/&gt; ClientRemoteSignal:wait() → any Yields the thread until the serverside remote signal (to which the client remote signal is connected to) dispatches some data to this client remote signal. ``lua -- Server remoteSignal:fireAllClients(&quot;Hi&quot;) -- Client print(clientRemoteSignal:wait()) --&gt; &quot;Hi&quot;  "},{"title":"destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#destroy","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:destroy() → () Destroys the client remote signal and renders it unusable. "},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#properties","content":" "},{"title":"updated​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#updated","content":"This item is read only and cannot be modified. Read Only Signal ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty.updated: Signal&lt;newValue: any&gt; A signal which is fired, whenever the value of the serverside remote property (to which this client remote property is connected) is updated. Incase the client has a specific value set for them in the serverside remote property, then this signal will only fire if that value has been updated.  "},{"title":"ClientRemoteProperty​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#ClientRemoteProperty","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; ClientRemoteProperty.ClientRemoteProperty: Type An exported Luau type of a client remote property object. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#functions","content":" "},{"title":"is​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#is","content":"&lt;/&gt; ClientRemoteProperty.is(self: any) → boolean Returns a boolean indicating if self is a client remote property or not.  "},{"title":"get​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#get","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:get() → any Returns the value of the client stored in the serverside remote property (to which the client remote property is connected to). If there is no value stored specifically for the client, then the serverside remote property's current value will be returned instead.  "},{"title":"destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#destroy","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:destroy() → () Destroys the client remote property and renders it unusable. "},{"title":"matrixUtil","type":0,"sectionRef":"#","url":"api/matrixUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"matrixUtil","url":"api/matrixUtil#functions","content":" "},{"title":"getMatchingRowsValue​","type":1,"pageTitle":"matrixUtil","url":"api/matrixUtil#getMatchingRowsValue","content":"&lt;/&gt; matrixUtil.getMatchingRowsValue( matrix: {{any}}, depth: number? ) → any Searches matrix row-wise, and returns a value in a row that matches with the rest of the values of that row. E.g: local matrix = { {1, 1, 1}, {5, 5, 2}, {0, 0, 2}, } print(matrixUtil.getMatchingRowsValue(matrix)) --&gt; 1 (The first row is equally matched (all 1s)) Additionally, you can specify depth if you want to control how far the method should check each row. For e.g: local matrix = { {1, 2, 3, 4}, {5, 6, 7, 8}, {1, 1, 1, 0}, } print(matrixUtil.getMatchingRowsValue(matrix, 3)) --&gt; 1 (The last row's first 3 values (1s) are equally matched) print(matrixUtil.getMatchingRowsValue(matrix, 4)) --&gt; nil (No row's first 4 values are equally matched)   "},{"title":"getMatchingDiagonalColumnsValue​","type":1,"pageTitle":"matrixUtil","url":"api/matrixUtil#getMatchingDiagonalColumnsValue","content":"&lt;/&gt; matrixUtil.getMatchingDiagonalColumnsValue( matrix: {{any}}, depth: number? ) → any Searches matrix diagonally, and returns a value that matches with the rest of the values of the arrays in matrix. E.g: local matrix = { {5, 0, 0}, {0, 5, 0}, {0, 0, 5}, } print(matrixUtil.getMatchingDiagonalColumnsValue(matrix)) --&gt; 1 (A column has matching values diagonally (just 5s)) Additionally, you can specify depth if you want to control how far the method should search matrix diagonally. For e.g: local matrix = { {2, 0, 0, 0}, {0, 2, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}, } print(matrix.getMatchingDiagonalColumnsValue(matrix, 3)) --&gt; 2 (A column has FIRST 3 matching values diagonally (just 2s))   "},{"title":"getMatchingColumnsValue​","type":1,"pageTitle":"matrixUtil","url":"api/matrixUtil#getMatchingColumnsValue","content":"&lt;/&gt; matrixUtil.getMatchingColumnsValue( matrix: {{any}}, depth: number? ) → any Searches matrix column-wise and returns a value of a column that matches with the rest of the values of that column. E.g: local matrix = { {5, 0, 0}, {5, 1, 0}, {5, 0, 1}, } print(matrixUtil.getMatchingColumnsValue(matrix)) --&gt; 5 (A column has ALL equally matching values (just 5s)) Additionally, you can specify depth if you want to control how far the method should check each column. For e.g: local matrix = { {5, 0, 0}, {5, 0, 0}, {2, 1, 1}, } print(matrixUtil.getMatchingColumnsValue(matrix, 2)) --&gt; 5 (A column has FIRST 2 matching values (just 5s))  "},{"title":"Queue","type":0,"sectionRef":"#","url":"api/Queue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Queue","url":"api/Queue#properties","content":" "},{"title":"progressed​","type":1,"pageTitle":"Queue","url":"api/Queue#progressed","content":"Signal Queue Instance &lt;/&gt; Queue.progressed: Signal&lt;callbackProgressed: () → (),deltaTime: number&gt; A signal which is fired whenever the queue is progressed, i.e when an appended callback (through Queue:append) is called. The callback called is passed as the first argument to the signal, and a second argument, deltaTime is also passed which is how long (in seconds) it took for the callback to be called ever since it was appended.  "},{"title":"Queue​","type":1,"pageTitle":"Queue","url":"api/Queue#Queue","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Queue.Queue: Type An exported Luau type of a queue object. "},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"api/Queue#new","content":"&lt;/&gt; Queue.new() → Queue A constructor method that creates a new queue object.  "},{"title":"is​","type":1,"pageTitle":"Queue","url":"api/Queue#is","content":"&lt;/&gt; Queue.is(self: any) → boolean A method that returns a boolean indicating if self is a queue or not.  "},{"title":"emptyQueue​","type":1,"pageTitle":"Queue","url":"api/Queue#emptyQueue","content":"Queue Instance &lt;/&gt; Queue:emptyQueue() → () Empties the queue, i.e all appended callbacks that are waiting to be resumed will never be resumed local queue = Queue.new() local promise1 = queue:append(function() task.wait(1) warn(&quot;called&quot;) --&gt; this never works, because the promise is cancelled -- as the queue is emptied! end) print(promise1:getStatus()) --&gt; &quot;Running&quot; (the promise is running) queue:emptyQueue() print(promise1:getStatus()) --&gt; &quot;Cancelled&quot; (the promise has been cancelled)   "},{"title":"append​","type":1,"pageTitle":"Queue","url":"api/Queue#append","content":"Queue Instance &lt;/&gt; Queue:append(callback: (deltaTime: number) → ()) → Promise&lt;deltaTime: number&gt; Appends callback to the queue so that it'll be called once the previous callbacks appended to the queue have finished running (or the promises associated to them have been canceled). callback upon being called is passed a number as the only argument (the time it took for it to be called ever since it was appended). The method also returns a promise, which to resolves with a number (the time it took for callback to run ever since it was appended), once callback is called. local queue = Queue.new() local promise1 = queue:append(function(deltaTime) print(deltaTime) --&gt; 5.00003807246685e-07 task.wait(5) end) local promise2 = queue:append(function(deltaTime) print(deltaTime) --&gt; 5.0113310999877285 task.wait(1) end) local promise2 = queue:append(function(deltaTime) print(deltaTime) --&gt; 6.012134199991124 end) tip The promise returned will be canceled if Queue:emptyQueue is called, but you can also manually just cancel the promise to effectively remove the added callback from the queue, e.g: local queue = Queue.new() local promise = queue:append(function(deltaTime) print(deltaTime) --&gt; never prints! end) promise:cancel() --&gt; Cancel the promise!   "},{"title":"destroy​","type":1,"pageTitle":"Queue","url":"api/Queue#destroy","content":"Queue Instance &lt;/&gt; Queue:destroy() → () Calls Queue:emptyQueue and renders the queue unusable. "},{"title":"numberUtil","type":0,"sectionRef":"#","url":"api/numberUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#properties","content":" "},{"title":"e​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#e","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; numberUtil.e: number&lt;2.7182818284590&gt; A mathematical constant, also known as Euler's number.  "},{"title":"phi​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#phi","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; numberUtil.phi: number&lt;1.618033988749895&gt; A mathematical constant, also known as the golden ratio.  "},{"title":"tau​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#tau","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; numberUtil.tau: number&lt;6.283185307179586&gt; A mathematical constant, it is the circle constant representing the ratio between circumference and radius.  "},{"title":"g​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#g","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; numberUtil.g: number&lt;6.6743e-11&gt; A mathematical constant, used in calculating the gravitational attraction between two objects. "},{"title":"Functions​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#functions","content":" "},{"title":"lerp​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#lerp","content":"&lt;/&gt; numberUtil.lerp( number: number, goal: number, alpha: number ) → number Interpolates number to goal, with alpha being the multiplier. print(numberUtil.lerp(2, 5, 0.7)) --&gt; 4.1   "},{"title":"quadraticLerp​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#quadraticLerp","content":"&lt;/&gt; numberUtil.quadraticLerp( number: number, goal: number, alpha: number ) → number Quadratic interpolates number to goal, with alpha being the multiplier. print(numberUtil.quadraticLerp(2, 5, 0.7)) --&gt; 4.1   "},{"title":"inverseLerp​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#inverseLerp","content":"&lt;/&gt; numberUtil.inverseLerp( min: number, max: number, alpha: number ) → number Inverse Lerp is the inverse operation of the Lerp Node. It can be used to determine what the input to a Lerp was based on its output. For e.g, the value of a Lerp between 0 and 2 with alpha being 1 is 0.5. Therefore the value of an Inverse Lerp between 0 and 2 with alpha being 0.5 is 1. print(numberUtil.inverseLerp(2, 5, 0.7)) --&gt; -0.43333333333333335   "},{"title":"average​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#average","content":"&lt;/&gt; numberUtil.average( sum: number, ...: number ) → number Returns the average of ... numbers against sum. print(numberUtil.average(100, 50, 25)) --&gt; 0.75   "},{"title":"suffix​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#suffix","content":"&lt;/&gt; numberUtil.suffix(number: number) → string Return a string as the formatted version of number. Cannot format extremely large numbers This method will struggle to format numbers larger than 10^68 approximately. print(numberUtil.suffix(10^70)) --&gt; 10 (this is wrong) print(numberUtil.suffix(10^68)) --&gt; 100c (this is correct) print(numberUtil.suffix(1650)) --&gt; &quot;1.65K&quot;   "},{"title":"formatToHMS​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#formatToHMS","content":"&lt;/&gt; numberUtil.formatToHMS(number: number) → string Returns a string which is just number formatted to the HMS (Hour, Minutes, Seconds) format. print(numberUtil.formatToHMS(21600)) --&gt; 06:00:00   "},{"title":"formatToMS​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#formatToMS","content":"&lt;/&gt; numberUtil.formatToMS(number: number) → string Returns a string which is just number formatted to the MS (Minutes, Seconds) format. print(numberUtil.formatToHMS(21600)) --&gt; 10:00   "},{"title":"map​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#map","content":"&lt;/&gt; numberUtil.map( number: number, inMin: number, inMax: number, outMin: number, outMax: number ) → number Maps number between inMin and inMax, and outMin and outMax. print(numberUtil.map(1,2,3,4,5)) --&gt; 3   "},{"title":"nan​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#nan","content":"&lt;/&gt; numberUtil.nan(number: number) → boolean Returns a boolean indicating if number is NaN (Not A Number). print(numberUtil.nan(0 / 0)) --&gt; true   "},{"title":"close​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#close","content":"&lt;/&gt; numberUtil.close( number: number, to: number, eplison: number? ) → boolean Returns a boolean indicating if the difference between number and to is lower than or equal to eplsion. print(numberUtil.close(0.1 + 0.2, 0.3)) --&gt; true print(numberUtil.close(0.1 + 0.2, 0.3, 0)) --&gt; false If eplison is not specified, then it will default to 1e-5.  "},{"title":"root​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#root","content":"&lt;/&gt; numberUtil.root( number: number, root: number ) → number Returns the root of number. print(numberUtil.root(2, 3)) --&gt; 1.2599210498948732 (same as cube root of 2) print(numberUtil.root(2, 2)) --&gt; 1.4142135623730951 (same as square root of 2)   "},{"title":"factorial​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#factorial","content":"&lt;/&gt; numberUtil.factorial(number: number) → number Returns the factorial of number. print(numberUtil.factorial(3)) --&gt; 6   "},{"title":"factors​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#factors","content":"&lt;/&gt; numberUtil.factors(number: number) → {number} Returns an array of all factors of number. print(numberUtil.factors(2)) --&gt; {1, 2}   "},{"title":"clampTo​","type":1,"pageTitle":"numberUtil","url":"api/numberUtil#clampTo","content":"&lt;/&gt; numberUtil.clampTo( number: number, min: number, max: number, clamp: number ) → number Clamps number to clamp, if number is greater than max or lower than min. print(numberUtil.clampTo(1, 2, 5, 150)) --&gt; 150  "},{"title":"NetworkServer","type":0,"sectionRef":"#","url":"api/NetworkServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#Middleware","content":"&lt;/&gt; interface Middleware { methodCallInbound: {( methodName: string, args: {any} ) → boolean}? methodCallOutbound: {( methodName: string, args: {any}, methodResponse: any ) → any}? } Both methodCallInbound and methodCallOutbound must be an array of callbacks if specified. methodCallInbound Callbacks in methodCallInbound are called whenever a client tries to call any of the appended methods of the network. The first argument passed to each callback is the name of the method (the client called), and the second argument, i.e the arguments sent by the client, which are packed into an array. local methodCallInboundCallbacks = { function (methodName, arguments) print(arguments[1]:IsA(&quot;Player&quot;)) --&gt; true (the first argument is always the client) print(typeof(arguments)) --&gt; &quot;table&quot; end } --- Yielding is not allowed Middleware callbacks aren't allowed to yield, if they do so, an error will be outputted! More control If any of the callbacks return an explicit false value, then the method which the client tried to call, will not be called. This is useful as you can implement for e.g, implementing rate limits! Additionally, you can modify the arguments table which will be reflected in the method, for e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = Network.Server.new(&quot;Test&quot;, {methodCallInbound = { function(_, arguments) arguments[2] = &quot;test&quot; end }}) testNetwork:append(&quot;method&quot;, function(player, a) print(a) --&gt; &quot;test&quot; (a ought to be 1, but the middleware modified it!) end) testNetwork:dispatch(Workspace) -- Client local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace) estNetwork.method(1) methodCallOutbound Callbacks in methodCallOutbound are called whenever a method (appended to the network) is called by the client, and has finished running. The first argument passed to each callback is the name of the method (client called), and the second argument, i.e the arguments sent by the client, which are packed into an array. local methodCallOutboundCallbacks = { function (methodName, arguments) print(arguments[1]:IsA(&quot;Player&quot;)) --&gt; true (the first argument is always the client) print(typeof(arguments)) --&gt; &quot;table&quot; end } --- Yielding is not allowed Middleware callbacks aren't allowed to yield, if they do so, an error will be outputted! Additional methodResponse argument A third argument i.e methodResponse is passed to each callback as well, which is just the response of the method called. For e.g: -- Server: local Workspace = game:GetService(&quot;Workspace&quot;) local middleware = { methodCallOutbound = { { function (methodName, arguments, methodResponse) print(methodResponse) --&gt; &quot;this&quot; return &quot;oops modified&quot; end } } } local Network = network.Server.new(&quot;test&quot;, middleware) Network:append(&quot;SomeMethod&quot;, function() return &quot;this&quot; end) Network:dispatch(Workspace) -- Client: local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;test&quot;, Workspace):expect() print(testNetwork.SomeMethod()) --&gt; &quot;oops modified&quot; (ought to be &quot;this&quot; instead but modified by a middleware!) Additionally, these callbacks can return a value that overrides the actual result of the method (which will be sent back to the client). For e.g: -- Server: local Workspace = game:GetService(&quot;Workspace&quot;) local middleware = { { function (methodName, arguments, methodResponse) print(methodResponse) --&gt; &quot;this&quot; return 50 end } } local testNetwork = network.Server.new(&quot;test&quot;, middleware) testNetwork:append(&quot;SomeMethod&quot;, function() return &quot;this&quot; end) testNetwork:dispatch(Workspace) -- Client: local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.fromParent(&quot;test&quot;, Workspace):expect() print(testNetwork.SomeMethod()) --&gt; 50 Additionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and then sent back to the client. This is by design, as it isn't ideal to disregard all returned values for just 1. For e.g: -- Server: local Workspace = game:GetService(&quot;Workspace&quot;) local middleware = { { function (methodName, arguments, response) return 1 end, function (methodName, arguments, response) return 2 end, function (methodName, arguments, response) return 3 end } } local testNetwork = network.server.new(&quot;test&quot;, middleware) testNetwork:append(&quot;someMethod&quot;, function() return &quot;this&quot; end) testNetwork:dispatch(Workspace) -- Client: local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;test&quot;, Workspace):expect() print(testNetwork.someMethod()) --&gt; {1, 2, 3}  "},{"title":"Properties​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#properties","content":" "},{"title":"RemoteProperty​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#RemoteProperty","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NetworkServer.RemoteProperty: RemoteProperty A reference to the RemoteProperty module.  "},{"title":"RemoteProperty​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#RemoteProperty","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NetworkServer.RemoteProperty: RemoteSignal A reference to the RemoteSignal module.  "},{"title":"NetworkServer​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#NetworkServer","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NetworkServer.NetworkServer: Type An exported Luau type of a network object. "},{"title":"Functions​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#new","content":"&lt;/&gt; NetworkServer.new( name: string, middleware: Middleware? ) → NetworkServer Creates and returns a new network object of the name i.e name. Precaution! The network object will initially not be accessible to the client. You need to call NetworkServer:dispatch to render the network object accessible to the client!  "},{"title":"is​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#is","content":"&lt;/&gt; NetworkServer.is(self: any) → boolean Returns a boolean indicating if self is a network object or not.  "},{"title":"isDispatched​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#isDispatched","content":"&lt;/&gt; NetworkServer:isDispatched() → boolean Returns a boolean indicating if the network object is dispatched to the client or not. Precaution! This method will always return false if the network object is destroyed.  "},{"title":"append​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#append","content":"&lt;/&gt; NetworkServer:append( key: string, value: any ) → () Appends a key-value pair, key and value, to the network object, so that it is available to the client once the network object is dispatched. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = Network.Server.new(&quot;test&quot;) testNetwork:append(&quot;key&quot;, &quot;the value!&quot;) testNetwork:dispatch(Workspace) -- Client local testNetwork = Network.client.fromParent(&quot;test&quot;, Workspace):expect() print(testNetwork.key) --&gt; &quot;the value!&quot; More support You can also append a RemoteSignal and a RemoteProperty as well, they'll be represented as a ClientRemoteSignal and a ClientRemoteProperty to the client respectively! Precaution! Argument limitations apply, as remote functions are internally used the key-value pairs accessible to the clients. warning This method will error if the network object is dispatched to the client. Always make sure to append keys and values before you dispatch the network object. You can check if a network object is dispatched to the client or not through NetworkServer:dispatched.  "},{"title":"dispatch​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#dispatch","content":"&lt;/&gt; NetworkServer:dispatch(parent: Instance ) → () Dispatches the network folder of the network object to parent, rendering the network object accessible to the client now. warning If another network object of the same name as this network object is already dispatched to parent, then this method will error - you can't have more than 1 network object of the same name dispatched to the same instance!  "},{"title":"destroy​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#destroy","content":"&lt;/&gt; NetworkServer:destroy() → () Destroys the network object and all appended remote properties &amp; remote signals within the network object, and renders the network object useless. "},{"title":"Property","type":0,"sectionRef":"#","url":"api/Property","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Property","url":"api/Property#properties","content":" "},{"title":"updated​","type":1,"pageTitle":"Property","url":"api/Property#updated","content":"This item is read only and cannot be modified. Read Only Signal Property Instance &lt;/&gt; Property.updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"Property​","type":1,"pageTitle":"Property","url":"api/Property#Property","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Property.Property: Type An exported Luau type of a property object. "},{"title":"Functions​","type":1,"pageTitle":"Property","url":"api/Property#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Property","url":"api/Property#new","content":"&lt;/&gt; Property.new(initialValue: any) → Property A constructor method that creates a new property object, with initialValue as the current value of the property.  "},{"title":"is​","type":1,"pageTitle":"Property","url":"api/Property#is","content":"&lt;/&gt; Property.is(self: any) → boolean A method that returns a boolean indicating if self is a property or not.  "},{"title":"set​","type":1,"pageTitle":"Property","url":"api/Property#set","content":"Property Instance &lt;/&gt; Property:set(value: any) → () Sets the value of the property to value, if this new value isn't the same as the previous value.  "},{"title":"deferredSet​","type":1,"pageTitle":"Property","url":"api/Property#deferredSet","content":"Property Instance &lt;/&gt; Property:deferredSet(value: any) → () Works the same as Property:set, except the updating of the property's value to value is deferred through task.defer.  "},{"title":"forceSet​","type":1,"pageTitle":"Property","url":"api/Property#forceSet","content":"Property Instance &lt;/&gt; Property:forceSet(value: any) → () Works the same as Property:set except that tables aren't checked for equality, e.g: local property = Property.new() property.updated:Connect(function(newVal) warn(newVal) --&gt; {1} end) local t = {1} property:forceSet(t) --&gt; Fires off the .Updated signal (expected) -- This ought to not fire off the signal, but the previous and new value -- aren't checked for equality since they're both tables) property:forceSet(t) -- Fires off the .Updated signal (expected as a number ~= table) property:forceSet(1) -- Does NOT fire off the .Updated signal, since the previous value -- (a number, not a table) and the new value (a number, not a table) are the -- same! property:forceSet(1)   "},{"title":"bulkSet​","type":1,"pageTitle":"Property","url":"api/Property#bulkSet","content":"Property Instance &lt;/&gt; Property:bulkSet(value: any) → () Works almost the same as Property:set, but never fires off the Property.updated signal.  "},{"title":"get​","type":1,"pageTitle":"Property","url":"api/Property#get","content":"Property Instance &lt;/&gt; Property:get() → any Returns the current value of the property. local property = Property.new() property:Set(5) print(property:get()) --&gt; 5   "},{"title":"destroy​","type":1,"pageTitle":"Property","url":"api/Property#destroy","content":"Property Instance &lt;/&gt; Property:destroy() → () Destroys the property and renders it unusable. "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Setup​","type":1,"pageTitle":"Installation","url":"docs/intro#wally-setup","content":"Once Wally is installed, run wally init on your project directory, and then add the various open-sourced modules that you need, as wally dependencies. For e.g, the following may be a wally.toml file for a project that includes a number wally package: [package] name = &quot;bubshayz/project&quot; version = &quot;1.0.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] numberUtil = &quot;bubshayz/numberUtil@1.1.0&quot;  Now, to install these dependencies, run wally install within your project. Wally will then create a package folder in your directory with the installed dependencies. Then use Rojo to sync in the package folder to Studio. "},{"title":"Usage Example​","type":1,"pageTitle":"Installation","url":"docs/intro#usage-example","content":"Once the above necessary steps are completed, the installed wally dependencies can now be used in code, e.g: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local numberUtil = require(ReplicatedStorage.Packages.numberUtil) print(numberUtil.factors(2)) --&gt; {1, 2}  "},{"title":"networkClient","type":0,"sectionRef":"#","url":"api/networkClient","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"networkClient","url":"api/networkClient#properties","content":" "},{"title":"ClientRemoteProperty​","type":1,"pageTitle":"networkClient","url":"api/networkClient#ClientRemoteProperty","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; networkClient.ClientRemoteProperty: ClientRemoteProperty A reference to the ClientRemoteProperty module.  "},{"title":"ClientRemoteSignal​","type":1,"pageTitle":"networkClient","url":"api/networkClient#ClientRemoteSignal","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; networkClient.ClientRemoteSignal: ClientRemoteSignal A reference to the ClientRemoteSignal module. "},{"title":"Functions​","type":1,"pageTitle":"networkClient","url":"api/networkClient#functions","content":" "},{"title":"allFromParent​","type":1,"pageTitle":"networkClient","url":"api/networkClient#allFromParent","content":"&lt;/&gt; networkClient.allFromParent(parent: Instance ) → {[string]: {[string]: any}} Returns an array of all networks dispatched to parent. -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local Network1 = network.Server.new(&quot;Test1&quot;, workspace) Network1:append(&quot;status&quot;, &quot;not good mate&quot;) Network1:dispatch(Workspace) local Network2 = network.Server.new(&quot;Test2&quot;, workspace) Network2:append(&quot;status&quot;, &quot;good mate!&quot;) Network2:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) for _, networkObject in Network.client.allFromParent(Workspace) do print(networkObject.status) end --&gt; &quot;not good mate&quot; --&gt; &quot;good mate!&quot;   "},{"title":"fromParent​","type":1,"pageTitle":"networkClient","url":"api/networkClient#fromParent","content":"&lt;/&gt; networkClient.fromParent( name: string, parent: Instance ) → Promise&lt;DispatchedNetwork: {[string]: any}&gt; Returns a promise which is resolved once a network with the name of name, is dispatched to parent. If a network with the name of name is already dispatched to parent, the promise will immediately resolve. For e.g: -- Server local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local network = require(ReplicatedStorage.Packages.network) local testNetwork = Network.Server.new(&quot;Test&quot;) testNetwork:append(&quot;method&quot;, function(player) return (&quot;hi, %s!&quot;):format(player.Name) end) -- Dispatch the network to workspace: testNetwork:dispatch(workspace) -- Client -- Get the network of name &quot;Test&quot;, dispatched to workspace local testNetwork = network.client.fromParent(&quot;Test&quot;, workspace) print(testNetwork.method()) --&gt; &quot;hi, bubshayz!&quot;  "},{"title":"instanceUtil","type":0,"sectionRef":"#","url":"api/instanceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#functions","content":" "},{"title":"setInstanceProperties​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#setInstanceProperties","content":"&lt;/&gt; instanceUtil.setInstanceProperties( instance: Instance , properties: {[string]: any} ) → () Sets the properties of instance from the properties table. instanceUtil.setInstanceProperties(workspace.Baseplate, {Transparency = 1}) print(workspace.Baseplate.Transparency) --&gt; 1   "},{"title":"setInstanceAttributes​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#setInstanceAttributes","content":"&lt;/&gt; instanceUtil.setInstanceAttributes( instance: Instance , attributes: {[string]: any} ) → () Sets the attributes of instance from the attributes table. instanceUtil.setInstanceAttributes(workspace.Baseplate, {IsMayoSauce = true}) print(workspace.Baseplate:GetAttribute(&quot;IsMayoSauce&quot;)) --&gt; true   "},{"title":"setInstancePhysicsCollisionGroup​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#setInstancePhysicsCollisionGroup","content":"&lt;/&gt; instanceUtil.setInstancePhysicsCollisionGroup( instance: Instance , collisionGroup: string ) → () Sets the collision group of instance to collisionGroup, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their collision group set to collisionGroup. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local PhysicsService = game:GetService(&quot;PhysicsService&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) PhysicsService:CreateCollisionGroup(&quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.Baseplate, &quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.SomeModel, &quot;Test&quot;)   "},{"title":"resetInstancePhysicsCollisionGroup​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#resetInstancePhysicsCollisionGroup","content":"&lt;/&gt; instanceUtil.resetInstancePhysicsCollisionGroup(instance: Instance ) → () Sets the collision group of instance to Default, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their collision group set to &quot;Default&quot;. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local PhysicsService = game:GetService(&quot;PhysicsService&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) PhysicsService:CreateCollisionGroup(&quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.Baseplate, &quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.SomeModel, &quot;Test&quot;) -- Okay on second thought, let's actually remove the collision group from these -- instances: instanceUtil.resetInstancePhysicsCollisionGroup(Workspace.Baseplate) instanceUtil.resetInstancePhysicsCollisionGroup(Workspace.SomeModel)   "},{"title":"setInstancePhysicalProperties​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#setInstancePhysicalProperties","content":"&lt;/&gt; instanceUtil.setInstancePhysicalProperties( instance: Instance , physicalProperties: PhysicalProperties ) → () Sets the PhysicalProperties of instance to physicalProperties, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their physical properties set to physicalProperties. local Workspace = game:GetService(&quot;Workspace&quot;) instanceUtil.setInstancePhysicalProperties(Workspace.Baseplate, PhysicalProperties.new(5, 2, 3)) print(Workspace.Baseplate.Density) --&gt; 5 print(Workspace.Baseplate.Elasticity) --&gt; 2 print(Workspace.Baseplate.ElasticityWeight) --&gt; 3   "},{"title":"resetInstancePhysicalProperties​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#resetInstancePhysicalProperties","content":"&lt;/&gt; instanceUtil.resetInstancePhysicalProperties(instance: Instance ) → () Sets the PhysicalProperties of instance to the default, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their physical properties set to the default. local Workspace = game:GetService(&quot;Workspace&quot;) instanceUtil.setInstancePhysicalProperties(Workspace.Baseplate, PhysicalProperties.new(5, 2, 3)) print(Workspace.Baseplate.Density) --&gt; 5 print(Workspace.Baseplate.Elasticity) --&gt; 2 print(Workspace.Baseplate.ElasticityWeight) --&gt; 3 -- Okay on second thought, let's remove the physical properties -- we've set on the instance: instanceUtil.resetInstancePhysicalProperties(Workspace.Baseplate) print(Workspace.Baseplate.Density) --&gt; 0.7 print(Workspace.Baseplate.Elasticity) --&gt; 0.5 print(Workspace.Baseplate.ElasticityWeight) --&gt; 1   "},{"title":"getInstanceCorners​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#getInstanceCorners","content":"&lt;/&gt; instanceUtil.getInstanceCorners(instance: BasePart ) → { top: {Vector3 }, bottom: {Vector3 } } Returns a read-only dictionary of all corners of instance, top and bottom.  "},{"title":"getInstanceFloorMaterial​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#getInstanceFloorMaterial","content":"&lt;/&gt; instanceUtil.getInstanceFloorMaterial( instance: BasePart , raycastParams: RaycastParams?, depth: number? ) → EnumItem  Returns the material the instance is lying on. If instance is underwater, then Enum.Material.Water will be returned, elseif instance is in air, then Enum.Material.Air will be returned. The 2nd argument can be passed as a RaycastParams object, which will be used in determining the material of instance through ray casting. The 3rd argument can be passed as a number (depth) which will increase the length of the ray by depth studs (on the Y-axis). This is only useful when you want to add in more leeway in determining the material of instance reliably, since sometimes the instance may be very slightly over the top of some ground due to its geometry so in those cases, the ray may not register properly. If this argument isn't specified, then it will default to 0.01.   "},{"title":"setInstanceNetworkOwner​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#setInstanceNetworkOwner","content":"&lt;/&gt; instanceUtil.setInstanceNetworkOwner( instance: BasePart , networkOwner: Player? ) → () Sets the network owner of instance to networkOwner safely. Safe to call This method should be preferred over directly setting the network owner of instance via SetNetworkOwner, as it won't error in cases where the network ownership API cannot be used on instance.  "},{"title":"getInstanceNetworkOwner​","type":1,"pageTitle":"instanceUtil","url":"api/instanceUtil#getInstanceNetworkOwner","content":"&lt;/&gt; instanceUtil.getInstanceNetworkOwner(instance: BasePart ) → Player?  Returns the network owner of instance safely. Safe to call This method should be preferred over directly getting the network owner of instance via GetNetworkOwner, as it will safely return nil (instead of erroring) in cases where the network ownership API cannot be used on instance! "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Disconnect: () → () Connected: boolean }   "},{"title":"Middleware​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Middleware","content":"&lt;/&gt; interface Middleware { serverEvent: {( client: Player , args: {any} ) → any}?, } serverEvent must be array of callbacks, if specified. serverEvent Callbacks in serverEvent are called whenever the client fires off the remote signal. The first and only argument passed to each callback is just an array of arguments sent by the client. local serverEventCallbacks = { function (arguments) print(client:IsA(&quot;Player&quot;)) --&gt; true (First argument is always the client!) end } --- Yielding is not allowed Middleware callbacks aren't allowed to yield, if they do so, an error will be outputted! More control If any of the callbacks return an explicit false value, then the remote signal will not be fired. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;Test&quot;) local TestRemoteSignal = network.Server.RemoteSignal.new({ clientServer = {function() return false end} }) TestRemoteSignal:connect(function() print(&quot;Fired&quot;) --&gt; never prints end) testNetwork:append(&quot;signal&quot;, TestRemoteSignal) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace) print(testNetwork.signal:fire()) Additionally, you can modify the arguments table, for e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;Test&quot;) local TestRemoteSignal = network.Server.RemoteSignal.new({ clientServer = { function(arguments) arguments[2] = 1 arguments[3] = &quot;test&quot; end } }) TestRemoteSignal:connect(function(client, a, b) print(a, b) --&gt; 1, &quot;test&quot; (a and b ought to be 24, but they were modified through the middleware) end) testNetwork:append(&quot;signal&quot;, TestRemoteSignal) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace) print(testNetwork.signal:fire(24, 24))  "},{"title":"Properties​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#properties","content":" "},{"title":"RemoteSignal​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#RemoteSignal","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteSignal.RemoteSignal: Type An exported Luau type of remote signal. "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#new","content":"&lt;/&gt; RemoteSignal.new(middleware: Middleware?) → RemoteSignal Creates and returns a new remote signal.  "},{"title":"is​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#is","content":"&lt;/&gt; RemoteSignal.is(self: any) → boolean Returns a boolean indicating if self is a remote signal or not.  "},{"title":"connectOnce​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#connectOnce","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:connectOnce(callback: (...any) → ()) → SignalConnection Works almost the same as RemoteSignal:connectOnce, except the connection returned is disconnected automatically once callback is called.  "},{"title":"connect​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#connect","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:connect(callback: (...any) → ()) → SignalConnection Connects callback to the remote signal so that it is called whenever the client fires the remote signal. Additionally, callback will be passed to all the arguments sent by the client.  "},{"title":"fireClient​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#fireClient","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireClient( client: Player , ...: any ) → () Fires the arguments ... to client.  "},{"title":"fireAllClients​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#fireAllClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireAllClients(...: any) → () Calls [remoteSignal:fireClient] on every player in the game.  "},{"title":"fireForClients​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#fireForClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireForClients( clients: {Player }, ...: any ) → () Calls [remoteSignal:fireClient] on every player in the clients table only.  "},{"title":"disconnectAll​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#disconnectAll","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:disconnectAll() → () Disconnects all connections connected via RemoteSignal:connect or RemoteSignal:connectOnce.  "},{"title":"destroy​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#destroy","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:destroy() → () Destroys the remote signal and renders it unusable. "},{"title":"windLines","type":0,"sectionRef":"#","url":"api/windLines","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"windLines","url":"api/windLines#types","content":" "},{"title":"WindLinesConfig​","type":1,"pageTitle":"windLines","url":"api/windLines#WindLinesConfig","content":"&lt;/&gt; interface WindLinesConfig { lifetime: number-- The life time of wind lines. direction: Vector3 -- The direction of wind lines. speed: number-- The speed at which wind lines move. spawnRate: number-- The rate at which wind lines are created. raycastParams: RaycastParams-- A RaycastParams object, to be used in determining if the player is under a roof or not. } This is a config template, none of these members are required in the config table when configuring windLines through windLines.SetConfig, however the config table must not be empty!  "},{"title":"DefaultWindLinesConfig​","type":1,"pageTitle":"windLines","url":"api/windLines#DefaultWindLinesConfig","content":"&lt;/&gt; interface DefaultWindLinesConfig { lifetime: 3 direction: Vector3.new(1,0,0) speed: 6 spawnRate: 25 raycastParams: nil } This is the default config template that windLines initially uses. You can configure windLines through windLines.SetConfig. "},{"title":"Properties​","type":1,"pageTitle":"windLines","url":"api/windLines#properties","content":" "},{"title":"effectStarted​","type":1,"pageTitle":"windLines","url":"api/windLines#effectStarted","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; windLines.effectStarted: Signal&lt;&gt; A signal which is fired whenever the wind lines effect starts.  "},{"title":"effectStopped​","type":1,"pageTitle":"windLines","url":"api/windLines#effectStopped","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; windLines.effectStopped: Signal&lt;&gt; A signal which is fired whenever the wind lines effect stops. "},{"title":"Functions​","type":1,"pageTitle":"windLines","url":"api/windLines#functions","content":" "},{"title":"isEffectStarted​","type":1,"pageTitle":"windLines","url":"api/windLines#isEffectStarted","content":"&lt;/&gt; windLines.isEffectStarted() → boolean Returns a boolean indicating if the wind lines effect is started.  "},{"title":"isStarted​","type":1,"pageTitle":"windLines","url":"api/windLines#isStarted","content":"&lt;/&gt; windLines.isStarted() → boolean Returns a boolean indicating if windLines is started through windLines.start.  "},{"title":"setConfig​","type":1,"pageTitle":"windLines","url":"api/windLines#setConfig","content":"&lt;/&gt; windLines.setConfig(newConfig: WindLinesConfig) → () Sets the current config of windLines to newConfig, so that this new config will be used for wind line effects. Cannot configure once started You cannot configure windLines once it is started, so always make sure to call this method before you start windLines!  "},{"title":"start​","type":1,"pageTitle":"windLines","url":"api/windLines#start","content":"&lt;/&gt; windLines.start() → () Starts up the wind lines effect. Custom behavior If the player is standing under a roof, then the wind lines effect will be stopped for realism purposes and this behavior cannot be toggled. However, you can adjust this behavior through windLines.setConfig through the RaycastParams member, since ray casting is used in determining if the player is standing under a roof. For e.g, the following config does not consider descendants in the filteredPartsFolder folder as roofs, so if a player stands under them, the wind lines effect will not be stopped: local Workspace = game:GetService(&quot;Workspace&quot;) local filteredPartsFolder = Workspace.SomeFolder local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {filteredPartsFolder} windLines.setConfig({raycastParams = raycastParams}) windLines.start()   "},{"title":"stop​","type":1,"pageTitle":"windLines","url":"api/windLines#stop","content":"&lt;/&gt; windLines.stop() → () Stops the wind lines effect. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"api/RemoteProperty","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Middleware","content":"&lt;/&gt; interface Middleware { clientSet: {( client: Player , value: any ) → any}?, } clientSet must be an array of callbacks, if specified. clientSet Callbacks in clientSet are called whenever the client tries to set the value of the remote property for themselves specifically. The first and only argument passed to each callback is just the client. local clientSetCallbacks = { function (client) print(client:IsA(&quot;Player&quot;)) --&gt; true end } --- Yielding is not allowed Middleware callbacks aren't allowed to yield, if they do so, an error will be outputted! More control A callback can return a non-nil value, which will then be set as the value for the client in the remote property. This is useful in cases where you want to have more control over what values the client can set for them in the remote property. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local TestRemoteProperty = Network.Server.RemoteProperty.new(50, { clientSet = {function() return &quot;rickrolled&quot; end} }) local testNetwork = Network.Server.new(&quot;Test&quot;) testNetwork:append(&quot;property&quot;, TestRemoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace):expect() testNetwork.property:set(1) print(testNetwork.updated:Wait()) --&gt; &quot;rickrolled&quot; (This ought to print 1, but our middleware returned a custom value!) Additionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and then sent back to the client. This is by design - as it isn't ideal to disregard all returned values for just 1. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local TestRemoteProperty = Network.Server.RemoteProperty.new(50, { clientSet = { function() return &quot;rickrolled&quot; end, function() return &quot;oof&quot; end, function() return &quot;hello&quot; end } }) local testNetwork = Network.Server.new(&quot;Test&quot;) testNetwork:append(&quot;property&quot;, TestRemoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace):expect() testNetwork.property:set(1) print(testNetwork.updated:Wait()) --&gt; {&quot;oofed&quot;, &quot;rickrolled&quot;, &quot;hello&quot;}  "},{"title":"Properties​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#properties","content":" "},{"title":"updated​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#updated","content":"This item is read only and cannot be modified. Read Only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the remote property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"clientValueUpdated​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#clientValueUpdated","content":"This item is read only and cannot be modified. Read Only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.clientValueUpdated: Signal&lt;client: Player, newValue: any&gt; A signal which is fired whenever the value of player specifically in the remote property is set to a new one. The signal is passed the player as the first argument, and the new specific value of player set in the remote property, as the second argument.  "},{"title":"RemoteProperty​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#RemoteProperty","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteProperty.RemoteProperty: Type An exported Luau type of a remote property. "},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#new","content":"&lt;/&gt; RemoteProperty.new( initialValue: any, middleware: Middleware? ) → RemoteProperty Creates and returns a new remote property with the value of initialValue.  "},{"title":"is​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#is","content":"&lt;/&gt; RemoteProperty.is(self: any) → boolean Returns a boolean indicating if self is a remote property or not.  "},{"title":"get​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#get","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:get() → any Returns the current value set for the remote property.  "},{"title":"setForClients​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#setForClients","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setForClients( clients: {Player }, value: any ) → () Calls RemoteProperty:setForClient for all clients in clients.  "},{"title":"setForClient​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#setForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setForClient( client: Player , value: any ) → () Sets the value of the remote property for client specifically, to value. Precaution! Argument limitations apply, as remote functions are internally used to render value accessible to the respective clients. Setting the value for client to nil will not remove the client's value -- call RemoteProperty:removeForClient to do that.   "},{"title":"removeForClient​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#removeForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:removeForClient(client: Player ) → () Removes the value stored for client specifically in the remote property.  "},{"title":"removeForClients​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#removeForClients","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:removeForClients(clients: {Player }) → () Calls RemoteProperty:removeForClient for all clients in the clients table.  "},{"title":"hasClientValueSet​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#hasClientValueSet","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:hasClientValueSet(client: Player ) → boolean Returns a boolean indicating if there is a specific value stored for client in the remote property.  "},{"title":"getForClient​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#getForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:getForClient(client: Player ) → any Returns the value stored specifically for client in the remote property.  "},{"title":"set​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#set","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:set(value: any) → () Sets the value of the remote property to value. Precaution! Argument limitations apply, as remote functions are internally used to render value accessible to the respective clients.  "},{"title":"destroy​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#destroy","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:destroy() → () Destroys the remote property and renders it unusable. "}]