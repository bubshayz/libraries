"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[629],{54832:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new network object of the name i.e `name`. \\n\\n:::note Precaution!\\nThe network object will initially not be accessible to the client. You need to call [NetworkServer:dispatch] \\nto render the network object accessible to the client!\\n:::","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"middleware","desc":"","lua_type":"Middleware?"}],"returns":[{"desc":"","lua_type":"NetworkServer"}],"function_type":"static","source":{"line":265,"path":"src/network/Server/init.lua"}},{"name":"is","desc":"Returns a boolean indicating if `self` is a network object or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":289,"path":"src/network/Server/init.lua"}},{"name":"isDispatched","desc":"Returns a boolean indicating if the network object is dispatched to the \\nclient or not. \\n\\n:::note Precaution!\\nThis method will always return false if the network object is destroyed.\\n:::","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":302,"path":"src/network/Server/init.lua"}},{"name":"append","desc":"Appends a key-value pair, `key` and `value`, to the network object, so that\\nit is available to the client once the network object is dispatched. \\n\\nFor e.g:\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = Network.Server.new(\\"TestNetwork\\")\\ntestNetwork:append(\\"key\\", \\"the value!\\")\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal testNetwork = Network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.key) --\x3e \\"the value!\\"\\n```\\n\\n:::tip More support\\nYou can also append a [RemoteSignal] and a [RemoteProperty] as well, they\'ll be represented as a [ClientRemoteSignal] and a [ClientRemoteProperty]\\nto the client respectively!\\n::: \\n\\n:::note Precaution!\\n[Argument limitations](https://create.roblox.com/docs/scripting/events/argument-limitations-for-bindables-and-remotes)\\napply, as remote functions are internally used the key-value pairs accessible to the clients.\\n:::\\n\\n:::warning\\nThis method will error if the network object is dispatched to the client. \\nAlways make sure to append keys and values *before* you dispatch the \\nnetwork object. You can check if a network object is dispatched to the \\nclient or not through [NetworkServer:dispatched].\\n:::","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":345,"path":"src/network/Server/init.lua"}},{"name":"dispatch","desc":"Dispatches the network folder of the network object to `parent`, rendering\\nthe network object accessible to the client now.\\n\\n:::warning\\nIf another network object of the same name as this network object is already\\ndispatched to `parent`, then this method will error - you can\'t have more than \\n1 network object of the same name dispatched to the same instance!\\n:::","params":[{"name":"parent","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":366,"path":"src/network/Server/init.lua"}},{"name":"destroy","desc":"Destroys the network object and all appended remote properties &\\nremote signals within the network object, and renders the network \\nobject useless. ","params":[],"returns":[],"function_type":"method","source":{"line":379,"path":"src/network/Server/init.lua"}}],"properties":[{"name":"RemoteProperty","desc":" ","lua_type":"RemoteProperty","readonly":true,"source":{"line":13,"path":"src/network/Server/init.lua"}},{"name":"RemoteProperty","desc":" ","lua_type":"RemoteSignal","readonly":true,"source":{"line":19,"path":"src/network/Server/init.lua"}},{"name":"NetworkServer","desc":" \\n\\nAn exported Luau type of network.","lua_type":"Type","readonly":true,"source":{"line":27,"path":"src/network/Server/init.lua"}}],"types":[{"name":"Middleware","desc":"Both `methodCallInbound` and `methodCallOutbound` must be an array of callbacks if specified. \\n\\n### `methodCallInbound` \\n\\nCallbacks in `methodCallInbound` are called whenever a client tries to call any of the appended methods of the network. \\n\\nThe first argument passed to each callback is the name of the method (the client called), and the second argument, i.e \\nthe arguments sent by the client, which are packed into an array. \\n\\n```lua\\nlocal methodCallInboundCallbacks = {\\n    function (methodName, arguments)\\n        print(arguments[1]:IsA(\\"Player\\")) --\x3e true (the first argument is always the client)\\n        print(typeof(arguments)) --\x3e \\"table\\"\\n    end\\n}\\n---\\n```\\n\\n:::warning Yielding is not allowed\\nMiddleware callbacks aren\'t allowed to yield. If they do so, their thread will be closed and an error will be outputted, but\\nother callbacks will not be affected.\\n:::\\n\\n:::tip More control\\n- If any of the callbacks return an **explicit** false value, then the method which the client tried to call, will *not* be\\ncalled. This is useful as you can implement for e.g, implementing rate limits!\\n\\n- Additionally, you can modify the `arguments` table which will be reflected in the method, for e.g:\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = Network.Server.new(\\"TestNetwork\\", {methodCallInbound = {\\n    function(_, arguments) \\n        arguments[2] = \\"test\\"\\n    end\\n}})\\ntestNetwork:append(\\"method\\", function(player, a)\\n    print(a) --\x3e \\"test\\" (a ought to be 1, but the middleware modified it!)\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nestNetwork.method(1) \\n```\\n:::\\n\\n### `methodCallOutbound` \\n\\nCallbacks in `methodCallOutbound` are called whenever a method (appended to the network) is called by the client, and \\nhas **finished** running.  \\n\\nThe first argument passed to each callback is the name of the method (client called), and the second argument, i.e \\nthe arguments sent by the client, which are packed into an array. \\n\\n```lua\\nlocal methodCallOutboundCallbacks = {\\n    function (methodName, arguments)\\n        print(arguments[1]:IsA(\\"Player\\")) --\x3e true (the first argument is always the client)\\n        print(typeof(arguments)) --\x3e \\"table\\"\\n    end\\n}\\n---\\n```\\n\\n:::warning Yielding is not allowed\\nMiddleware callbacks aren\'t allowed to yield. If they do so, their thread will be closed and an error will be outputted, but\\nother callbacks will not be affected.\\n:::\\n\\n:::tip \\nA third argument i.e `methodResponse` is passed to each callback as well, which is just the response of the method called. For e.g:\\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n    methodCallOutbound = {\\n        {\\n            function (methodName, arguments, methodResponse)\\n                print(methodResponse) --\x3e \\"this\\"\\n                return \\"oops modified\\"\\n            end\\n        }\\n    }\\n}\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", middleware)\\ntestNetwork:append(\\"someMethod\\", function()\\n    return \\"this\\"\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"testNetwork\\", Workspace):expect()\\nprint(testNetwork.someMethod()) --\x3e \\"oops modified\\" (ought to be \\"this\\" instead but modified by a middleware!)\\n```\\n\\nAdditionally, these callbacks can return a value that overrides the actual result of the method (which will be sent\\nback to the client). For e.g:\\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n    {\\n        function (methodName, arguments, methodResponse)\\n            print(methodResponse) --\x3e \\"this\\"\\n            return 50\\n        end\\n    }\\n}\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", middleware)\\ntestNetwork:append(\\"someMethod\\", function()\\n    return \\"this\\"\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someMethod()) --\x3e 50 \\n```\\n\\nAdditionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and *then* sent\\nback to the client. This is by design, as it isn\'t ideal to disregard all returned values for just 1.\\n\\nFor e.g: \\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n    {\\n        function (methodName, arguments, response)\\n            return 1\\n        end,\\n\\n        function (methodName, arguments, response)\\n            return 2\\n        end,\\n\\n        function (methodName, arguments, response)\\n            return 3\\n        end\\n    }\\n}\\n\\nlocal testNetwork = network.server.new(\\"TestNetwork\\", middleware)\\ntestNetwork:append(\\"someMethod\\", function()\\n    return \\"this\\"\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someMethod()) --\x3e {1, 2, 3} \\n```\\n:::","fields":[{"name":"methodCallInbound","lua_type":"{ (methodName: string, args: {any}) -> boolean}?","desc":""},{"name":"methodCallOutbound","lua_type":"{(methodName: string, args: {any}, methodResponse: any) -> any}?","desc":""}],"source":{"line":208,"path":"src/network/Server/init.lua"}}],"name":"NetworkServer","desc":"The server counterpart of [network].","realm":["Server"],"source":{"line":7,"path":"src/network/Server/init.lua"}}')}}]);