"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[861],{77062:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"A constructor method that creates a new queue object.","params":[],"returns":[{"desc":"","lua_type":"Queue"}],"function_type":"static","source":{"line":60,"path":"src/Queue/init.lua"}},{"name":"is","desc":"A method that returns a boolean indicating if `self` is a queue or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":71,"path":"src/Queue/init.lua"}},{"name":"emptyQueue","desc":"Empties the queue, i.e all appended callbacks that are waiting to be resumed \\nwill never be resumed\\n\\n```lua\\nlocal queue = Queue.new()\\n\\nlocal promise1 = queue:append(function()\\n    task.wait(1)\\n    warn(\\"called\\") --\x3e this never works, because the promise is cancelled\\n    -- as the queue is emptied! \\nend)\\n\\nprint(promise1:getStatus()) --\x3e \\"Running\\" (the promise is running)\\nqueue:emptyQueue() \\nprint(promise1:getStatus()) --\x3e \\"Cancelled\\"  (the promise has been cancelled)\\n```","params":[],"returns":[],"function_type":"method","tags":["Queue Instance"],"source":{"line":96,"path":"src/Queue/init.lua"}},{"name":"append","desc":"Appends `callback` to the queue so that it\'ll be called once the previous \\ncallbacks appended to the queue have *finished* running (or the promises \\nassociated to them have been canceled). `callback` upon being called is \\npassed a number as the only argument (the time it took for it to be called \\never since it was appended). \\n\\nThe method also returns a promise, which to resolves with a number \\n(the time it took for `callback` to run ever since it was appended), once `callback` is called.\\n\\n```lua\\nlocal queue = Queue.new()\\n\\nlocal promise1 = queue:append(function(deltaTime)\\n    print(deltaTime) --\x3e 5.00003807246685e-07 \\n    task.wait(5)\\nend)\\n\\nlocal promise2 = queue:append(function(deltaTime) \\n    print(deltaTime) --\x3e 5.0113310999877285\\n    task.wait(1)\\nend)\\n\\nlocal promise2 = queue:append(function(deltaTime) \\n    print(deltaTime) --\x3e 6.012134199991124 \\nend)\\n```\\n\\n:::tip\\nThe promise returned will be canceled if [Queue:emptyQueue] is called, but \\nyou can also manually  just cancel the promise to effectively remove the \\nadded callback from the queue, e.g:\\n\\n```lua\\nlocal queue = Queue.new()\\n\\nlocal promise = queue:append(function(deltaTime) \\n    print(deltaTime) --\x3e never prints!\\nend)\\n\\npromise:cancel() --\x3e Cancel the promise!\\n```\\n:::","params":[{"name":"callback","desc":"","lua_type":"(deltaTime: number) -> ()"}],"returns":[{"desc":"","lua_type":"Promise <deltaTime: number>"}],"function_type":"method","tags":["Queue Instance"],"source":{"line":152,"path":"src/Queue/init.lua"}},{"name":"destroy","desc":"Calls [Queue:emptyQueue] and renders the queue unusable.","params":[],"returns":[],"function_type":"method","tags":["Queue Instance"],"source":{"line":188,"path":"src/Queue/init.lua"}}],"properties":[{"name":"progressed","desc":" \\n\\nA [signal](https://sleitnick.github.io/RbxUtil/api/Signal/) which is fired \\nwhenever the queue is progressed, i.e when an appended callback (through [Queue:append]) is called. The \\ncallback called is passed as the first argument to the signal, and a second argument, `deltaTime` is also \\npassed which is how long (in seconds) it took for the callback to be called ever since it was appended.","lua_type":"Signal <callbackProgressed: () -> (), deltaTime: number>","tags":["Signal","Queue Instance"],"source":{"line":34,"path":"src/Queue/init.lua"}},{"name":"Queue","desc":" \\n\\nAn exported Luau type of a queue object.","lua_type":"Type","readonly":true,"source":{"line":42,"path":"src/Queue/init.lua"}}],"types":[],"name":"Queue","desc":" \\n\\nA class for creating queues. A queue in layman\'s terms is simply an object to which\\nyou can append callbacks, which will run based on when they\'re added --\\nthey follow the *FIFO (First In, First Out) pattern*.\\n \\n```lua\\nlocal queue = Queue.new()\\n\\nfor i = 1, 3 do \\n    queue:append(function(deltaTime)\\n        warn((\\"completed task (%d) in %s seconds.\\"):format(task.wait(i), deltaTime))\\n    end)\\nend\\n\\n--\x3e \\"completed task (1)\\" \\n--\x3e \\"completed task (2)\\"\\n--\x3e \\"completed task (3)\\"\\n```","source":{"line":22,"path":"src/Queue/init.lua"}}')}}]);